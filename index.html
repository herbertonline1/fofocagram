<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FofocaGram - Rede Social</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
<!-- Font Awesome para ícones -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Grand+Hotel&display=swap" rel="stylesheet">

<style>
  /* Reset e básico */
  * {
    box-sizing: border-box;
  }
  body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 0;
    background: #fafafa;
    color: #262626;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
  }
  header {
    background: #fff;
    border-bottom: 1px solid #dbdbdb;
    color: #262626;
    padding: 0.8rem 1rem;
    width: 100%;
    box-shadow: 0 1px 0 rgba(0,0,0,0.05);
    position: sticky;
    top: 0;
    z-index: 1000;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  header h1 {
    font-family: 'Grand Hotel', cursive;
    font-size: 2.2rem;
    margin: 0;
    color: #262626;
  }
  .header-user-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .header-user-controls #user-email {
    font-weight: 600;
    color: #262626;
    font-size: 0.9rem;
  }
  .header-user-controls #logout-btn {
    background: #ed4956;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 0.4rem 0.8rem;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    margin: 0;
    width: auto;
  }
  .header-user-controls #logout-btn:hover {
    background: #cc3745;
  }

  /* Layout principal */
  .app-container {
    display: grid;
    grid-template-columns: 220px 1fr 320px;
    gap: 2rem;
    max-width: 1200px;
    margin: 2rem auto;
    width: 100%;
  }

  /* Sidebar */
  .sidebar {
    position: sticky;
    top: 1rem;
    height: fit-content;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 1rem;
    background: #fff;
    border: 1px solid #dbdbdb;
    border-radius: 8px;
  }
  .sidebar a {
    text-decoration: none;
    color: #262626;
    font-weight: 500;
    font-size: 1.1rem;
    padding: 0.8rem;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 0.8rem;
    cursor: pointer;
  }
  .sidebar a:hover {
    background: #efefef;
  }
  .sidebar a i {
    font-size: 1.3rem;
  }

  /* Main feed */
  .main-feed {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* Barra de usuários que sigo */
  .following-bar {
    background: #fff;
    border: 1px solid #dbdbdb;
    padding: 0.8rem;
    border-radius: 8px;
    display: flex;
    gap: 1rem;
    overflow-x: auto;
    white-space: nowrap;
    -webkit-overflow-scrolling: touch;
  }
  .following-user-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-decoration: none;
    color: #262626;
    font-size: 0.8rem;
    cursor: pointer; /* Adicionado para indicar clicável */
  }
  .following-user-item span {
    margin-top: 0.4rem;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 70px;
  }

  /* NOVOS ESTILOS PARA BORDAS DE STORY */
  .story-circle {
    position: relative;
    width: 66px; /* Tamanho do círculo externo */
    height: 66px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0; /* Evita que o item encolha */
  }

  /* Borda degradê para stories não visualizados */
  .story-circle.has-story {
    background-image: linear-gradient(to top right, #feda75, #fa7e1e, #d62976, #962fbf, #4f5bd5);
    padding: 3px; /* Espessura da borda */
  }

  /* Círculo interno branco para criar o efeito de anel */
  .story-circle.has-story .inner-circle {
    background-color: #fff; /* Fundo branco para o anel */
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%; /* Ocupa o espaço do pai (story-circle) menos o padding */
    height: 100%;
  }

  /* Borda cinza para stories já visualizados ou sem stories ativos */
  .story-circle.story-viewed {
    border: 2px solid #dbdbdb; /* Borda cinza clara */
    padding: 0; /* Sem padding extra para a borda */
  }
  .story-circle.story-viewed .inner-circle {
    background-color: transparent; /* Não precisa de fundo branco */
    width: 100%;
    height: 100%;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .following-user-item img {
    width: 60px; /* Tamanho da imagem de perfil */
    height: 60px;
    border-radius: 50%;
    object-fit: cover;
  }
  /* FIM DOS NOVOS ESTILOS PARA BORDAS DE STORY */


  /* Rightbar */
  .rightbar {
    position: sticky;
    top: 1rem;
    height: fit-content;
  }

  /* Geral */
  main {
    width: 100%;
    margin: 0;
    padding: 0;
  }
  section {
    background: #fff;
    border: 1px solid #dbdbdb;
    border-radius: 3px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  }
  h2 {
    margin-top: 0;
    margin-bottom: 1.5rem;
    font-size: 1.4rem;
    color: #262626;
    text-align: center;
  }
  input, textarea, button {
    width: 100%;
    padding: 0.7rem;
    margin: 0.5rem 0 1rem 0;
    border-radius: 3px;
    border: 1px solid #dbdbdb;
    font-size: 1rem;
    background-color: #fafafa;
    color: #262626;
  }
  input:focus, textarea:focus {
    outline: none;
    border-color: #a8a8a8;
  }
  button {
    background: #0095f6;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
  }
  button:hover {
    background: #007acc;
  }
  button:disabled {
    background: #b2dffc;
    cursor: not-allowed;
  }
  /* Importante: use !important para garantir que a classe hidden sobrescreva outros estilos */
  .hidden {
    display: none !important;
  }
  #feed {
    margin-top: 0;
  }
  .post {
    background: #fff;
    border: 1px solid #dbdbdb;
    border-radius: 3px;
    margin-bottom: 1.5rem;
    padding: 0;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  }
  .post:last-child {
    margin-bottom: 0;
  }
  .post-header {
    display: flex;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid #efefef;
    position: relative;
  }
  .post-user {
    font-weight: 600;
    color: #262626;
    margin-right: auto;
  }
  .post-date {
    font-size: 0.75rem;
    color: #8e8e8e;
  }
  .post-image {
    width: 100%;
    display: block;
    object-fit: cover;
  }
  .post-video, .post-tiktok-video { /* Adicionado .post-tiktok-video */
    width: 100%;
    height: 315px; /* Altura padrão para vídeos do YouTube e TikTok */
    display: block;
  }
  .post-content {
    padding: 0 1rem 1rem 1rem;
  }
  .post-text {
    margin: 0.8rem 0;
    white-space: pre-wrap;
    font-size: 0.95rem;
    line-height: 1.4;
  }
  .post-actions {
    display: flex;
    gap: 0.5rem;
    font-size: 1.4rem;
    color: #262626;
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
  }
  .post-actions button {
    background: none;
    border: none;
    color: #262626;
    cursor: pointer;
    padding: 0;
    width: auto;
    margin: 0;
    font-size: 1.4rem;
  }
  .post-actions button.liked {
    color: #ed4956;
  }
  .post-likes-count {
    font-weight: 600;
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
  }
  .post-comments-count {
    font-size: 0.85rem;
    color: #8e8e8e;
    margin-top: 0.3rem;
    cursor: pointer;
    display: block;
  }
  .post-comments-count:hover {
    text-decoration: underline;
  }
  #comments-section {
    margin-top: 0.5rem;
    border-top: 1px solid #efefef;
    padding-top: 0.8rem;
  }
  .comment {
    font-size: 0.85rem;
    margin-bottom: 0.4rem;
    line-height: 1.3;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .comment-text-container {
    flex-grow: 1;
  }
  .comment-user {
    font-weight: 600;
    margin-right: 0.3rem;
  }
  .comment-actions {
    display: flex;
    gap: 0.5rem;
    margin-left: 1rem;
  }
  .comment-actions button {
    background: none;
    border: none;
    color: #8e8e8e;
    cursor: pointer;
    padding: 0;
    font-size: 0.8rem;
    width: auto;
    margin: 0;
  }
  .comment-actions button:hover {
    color: #262626;
  }
  .comment-form {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.8rem;
    border-top: 1px solid #efefef;
    padding-top: 0.8rem;
  }
  .comment-form input {
    flex: 1;
    margin: 0;
    padding: 0.6rem;
    background-color: #efefef;
    border: 1px solid #dbdbdb;
  }
  .comment-form button {
    width: auto;
    padding: 0.6rem 1rem;
    margin: 0;
    font-size: 0.9rem;
    background: #0095f6;
  }
  #follow-section {
    margin-top: 0;
  }
  #users-list {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #efefef;
    border-radius: 3px;
    padding: 0.5rem;
    background-color: #fafafa;
  }
  .user-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.6rem 0.5rem;
    border-bottom: 1px solid #efefef;
  }
  .user-item:last-child {
    border-bottom: none;
  }
  .user-name {
    font-weight: 500;
    color: #262626;
  }
  .follow-btn {
    background: #0095f6;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 0.4rem 0.8rem;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
  }
  .follow-btn.following {
    background: #efefef;
    color: #262626;
    border: 1px solid #dbdbdb;
  }
  #loading {
    text-align: center;
    margin-top: 1rem;
    color: #8e8e8e;
    font-size: 0.9rem;
  }
  #auth-section {
    max-width: 350px;
    margin: 2rem auto;
    padding: 2.5rem;
    text-align: center;
  }
  #auth-section h2 {
    margin-bottom: 2rem;
    font-size: 1.8rem;
    font-family: 'Grand Hotel', cursive;
  }
  #auth-section button {
    margin-bottom: 0.5rem;
  }
  #auth-section p {
    margin-top: 1rem;
  }
  #post-section {
    /* Esta seção agora está dentro do popup, então não precisa de margin-bottom */
    margin-bottom: 0;
    padding: 0; /* O padding será do popup-content */
    border: none; /* O border será do popup-content */
    box-shadow: none; /* O shadow será do popup-content */
  }
  #post-section textarea {
    min-height: 80px;
    resize: vertical;
  }
  #post-image-input, #post-media-url { /* Adicionado #post-media-url */
    padding: 0.5rem;
    background-color: transparent;
    border: 1px solid #dbdbdb; /* Adicionado borda para o input de URL */
    margin-bottom: 0.5rem;
  }
  #post-image-input::-webkit-file-upload-button {
    background: #0095f6;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.9rem;
    margin-right: 10px;
  }
  #post-image-input::-webkit-file-upload-button:hover {
    background: #007acc;
  }
  .post-owner-actions {
    position: absolute;
    top: 1rem;
    right: 2rem;
    display: flex;
    gap: 0.5rem;
  }
  .post-owner-actions button {
    background: none;
    border: none;
    color: #8e8e8e;
    cursor: pointer;
    font-size: 0.9rem;
    padding: 0.2rem 0.4rem;
    width: auto;
    margin: 0;
  }
  .post-owner-actions button:hover {
    color: #262626;
  }

  /* Popup */
  .popup-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
  }
  .popup-content {
    background: #fff;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    position: relative;
    width: 90%;
    max-width: 500px;
  }
  .close-popup-btn {
    position: absolute;
    top: 10px; right: 10px;
    background: none;
    border: none;
    font-size: 1.5rem;
    color: #8e8e8e;
    cursor: pointer;
    padding: 0.5rem;
    width: auto;
    margin: 0;
  }
  .close-popup-btn:hover {
    color: #262626;
  }

  /* Seção de Perfil */
  #profile-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem;
    background: #fff;
    border: 1px solid #dbdbdb;
    border-radius: 8px;
    max-width: 500px; /* Limita a largura para mobile */
    margin: 2rem auto; /* Centraliza */
  }
  #profile-section h2 {
    margin-bottom: 1rem;
    font-size: 1.8rem;
    color: #262626;
  }
  #profile-section p {
    font-size: 1.1rem;
    font-weight: 500;
    margin-bottom: 1.5rem;
    color: #262626;
  }
  #profile-section button {
    background: none;
    border: none;
    color: #0095f6;
    font-size: 1rem;
    padding: 0.5rem 0;
    cursor: pointer;
    width: auto; /* Para que o botão não ocupe 100% da largura */
    margin: 0.5rem 0;
    text-align: center;
  }
  #profile-section button:hover {
    text-decoration: underline;
  }
  #profile-section #logout-btn-profile {
    color: #ed4956;
    font-weight: 600;
    margin-top: 1.5rem;
  }
  #profile-section #logout-btn-profile:hover {
    color: #cc3745;
  }
  /* Adicionado para a imagem de perfil */
  #profile-picture {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 1rem;
    border: 3px solid #0095f6;
    padding: 3px;
  }
  #profile-picture-url-input {
    margin-bottom: 1rem;
  }


  /* Estilos para a seção de publicações do perfil */
  #profile-posts-section {
    width: 100%;
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 1px solid #dbdbdb;
  }
  #profile-posts-section h3 {
    text-align: center;
    margin-bottom: 1.5rem;
    font-size: 1.2rem;
    color: #262626;
  }
  #profile-posts-feed {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* Popup de Stories */
  #story-viewer-popup {
    background: #000; /* Fundo preto para stories */
    color: #fff;
  }
  #story-viewer-popup .popup-content {
    background: #000;
    padding: 0;
    max-width: 400px; /* Largura ideal para stories */
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #story-viewer-popup .close-popup-btn {
    color: #fff;
    z-index: 1;
  }
  #story-viewer-content {
    position: relative;
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #story-viewer-image, #story-viewer-video { /* Adicionado #story-viewer-video */
    max-width: 100%;
    max-height: 100%;
    object-fit: contain; /* Garante que a imagem/vídeo se ajuste sem cortar */
  }
  #story-viewer-video {
    width: 100%;
    height: auto; /* Ajusta a altura automaticamente */
  }
  #story-viewer-info {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(0,0,0,0.5);
    padding: 5px 10px;
    border-radius: 5px;
  }
  #story-viewer-info img {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    object-fit: cover;
  }
  #story-viewer-info span {
    font-weight: bold;
    font-size: 0.9rem;
  }
  #story-viewer-info .story-date {
    font-size: 0.75rem;
    color: #bbb;
    margin-left: auto;
  }
  /* Estilo para o botão de exclusão de story */
  #story-viewer-info .delete-story-btn {
    background: none;
    border: none;
    color: #ed4956; /* Cor vermelha para exclusão */
    font-size: 1.1rem;
    cursor: pointer;
    padding: 0;
    margin-left: 10px; /* Espaçamento do lado direito */
  }
  #story-viewer-info .delete-story-btn:hover {
    color: #cc3745;
  }

  #story-viewer-controls {
    position: absolute;
    top: 50%;
    width: 100%;
    display: flex;
    justify-content: space-between;
    transform: translateY(-50%);
    padding: 0 5px;
  }
  #story-viewer-controls button {
    background: rgba(0,0,0,0.3);
    border: none;
    color: #fff;
    font-size: 1.5rem;
    padding: 0.5rem;
    border-radius: 50%;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #story-viewer-controls button:hover {
    background: rgba(0,0,0,0.5);
  }
  #story-viewer-actions {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    border-top: 1px solid rgba(255,255,255,0.1);
  }
  #story-viewer-actions .comment-form {
    border-top: none;
    padding-top: 0;
  }
  #story-viewer-actions .comment-form input {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
    color: #fff;
  }
  #story-viewer-actions .comment-form input::placeholder {
    color: #ccc;
  }
  #story-viewer-actions .comment-form button {
    background: #0095f6;
  }
  #story-viewer-actions .post-actions button {
    color: #fff;
  }
  #story-viewer-actions .post-actions button.liked {
    color: #ed4956;
  }
  #story-viewer-actions .post-likes-count {
    color: #fff;
  }
  #story-viewer-comments-list {
    max-height: 100px; /* Altura máxima para a lista de comentários */
    overflow-y: auto;
    margin-bottom: 0.5rem;
    padding-right: 5px; /* Para a barra de rolagem */
  }
  #story-viewer-comments-list .comment {
    color: #fff;
  }
  #story-viewer-comments-list .comment-user {
    color: #fff;
  }
  #story-viewer-comments-list .comment-actions button {
    color: #bbb;
  }

  /* Estilos para o popup de notificações */
  #notifications-popup .popup-content {
    max-width: 450px;
    max-height: 80vh;
    overflow-y: auto;
  }
  #notifications-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  #notifications-list li {
    padding: 10px 0;
    border-bottom: 1px solid #eee;
    font-size: 0.9rem;
    color: #262626;
  }
  #notifications-list li:last-child {
    border-bottom: none;
  }
  #notifications-list li strong {
    font-weight: 600;
  }
  #notifications-list li .notification-date {
    font-size: 0.75rem;
    color: #8e8e8e;
    margin-left: 5px;
  }

  /* Estilo para o contador de notificações no ícone de sino */
  #notification-count {
    background-color: #ed4956; /* Cor de fundo vermelha */
    color: white; /* Cor do texto branca */
    border-radius: 50%; /* Forma circular */
    padding: 2px 6px; /* Preenchimento para o número */
    font-size: 0.7rem; /* Tamanho da fonte menor */
    position: absolute; /* Posicionamento absoluto em relação ao pai */
    top: 0px; /* Ajuste a posição vertical */
    right: 0px; /* Ajuste a posição horizontal */
    transform: translate(50%, -50%); /* Centraliza o badge */
    min-width: 18px; /* Largura mínima para números de um dígito */
    text-align: center; /* Centraliza o texto */
    line-height: 1; /* Altura da linha para centralizar verticalmente */
    box-shadow: 0 0 0 2px #fff; /* Borda branca para destaque */
  }


  /* Responsividade */
  @media (max-width: 992px) {
    .app-container {
      grid-template-columns: 1fr;
      margin: 1rem auto;
      padding-bottom: 60px;
    }
    .sidebar {
      display: none; /* Esconde a sidebar em mobile */
    }
    /* Mostra o rightbar (sugestões) em mobile */
    .rightbar {
      display: block; /* Altera de none para block */
      position: static; /* Remove o sticky para fluir com o conteúdo */
      margin: 1rem; /* Adiciona margem para não colar nas bordas */
      padding: 1rem;
      background: #fff;
      border: 1px solid #dbdbdb;
      border-radius: 8px;
    }
    main {
      max-width: 100%;
    }
    section, .post {
      border-left: none;
      border-right: none;
      border-radius: 0;
      margin-bottom: 1rem;
    }
    header {
      padding: 0.5rem 1rem;
    }
    /* Esconde os controles do header em mobile */
    .header-user-controls {
      display: none;
    }
    #auth-section {
      margin: 1rem;
      padding: 1.5rem;
    }
    .bottom-nav {
      display: flex;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #fff;
      border-top: 1px solid #dbdbdb;
      padding: 0.5rem 0;
      justify-content: space-around;
      align-items: center;
      z-index: 1000;
      box-shadow: 0 -1px 5px rgba(0,0,0,0.05);
    }
    .bottom-nav a {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-decoration: none;
      color: #262626;
      font-size: 0.7rem;
      font-weight: 500;
      padding: 0.2rem;
      cursor: pointer;
    }
    .bottom-nav a i {
      font-size: 1.5rem;
      margin-bottom: 0.2rem;
    }
    .bottom-nav a:hover {
      color: #0095f6;
    }
    /* Garante que a seção de perfil seja visível em mobile quando ativada */
    #profile-section.hidden-mobile {
        display: none !important;
    }
    #profile-section:not(.hidden-mobile) {
        display: flex; /* Ou block, dependendo do layout desejado */
    }
    /* Ajuste para o link do ícone de notificações para posicionamento relativo */
    .bottom-nav a#bottom-nav-notifications {
      position: relative;
    }
  }

  /* Esconde a seção de perfil por padrão em desktop */
  @media (min-width: 993px) {
    #profile-section {
        display: none !important;
    }
  }
</style>
</head>
<body>

<header>
  <h1>FofocaGram</h1>
  <div class="header-user-controls" id="header-user-controls-desktop">
    <span id="user-email-desktop"></span>
    <button id="logout-btn-desktop">Sair</button>
  </div>
</header>

<main>
  <!-- Área de autenticação -->
  <section id="auth-section">
    <h2>FofocaGram</h2>
    <input type="email" id="email" placeholder="Email" />
    <input type="password" id="password" placeholder="Senha" />
    <button id="login-btn">Entrar</button>
    <button id="signup-btn">Cadastrar</button>
    <p id="auth-error" style="color:red;"></p>
  </section>

  <!-- Área principal após login -->
  <div class="app-container hidden" id="app-section">
    <!-- Sidebar (visível apenas em telas maiores) -->
    <nav class="sidebar">
      <a href="#" id="sidebar-home"><i class="fas fa-home"></i> Página Inicial</a>
      <a href="#"><i class="fas fa-compass"></i> Explorar</a>
      <a href="#"><i class="fas fa-video"></i> Reels</a>
      <a href="#"><i class="fas fa-heart"></i> Notificações</a>
      <a href="#" id="menu-criar"><i class="fas fa-plus-square"></i> Criar</a>
      <a href="#" id="sidebar-profile"><i class="fas fa-user-circle"></i> Perfil</a>
      <a href="#" id="menu-criar-story"><i class="fas fa-camera"></i> Criar Story</a>
    </nav>

    <!-- Coluna central -->
    <div class="main-feed" id="main-feed-content">
      <!-- Barra de usuários que sigo -->
      <div class="following-bar" id="following-bar">
        <!-- JS vai preencher com usuários que você segue -->
      </div>

      <!-- Feed -->
      <section id="feed-section">
        <div id="feed"></div>
        <p id="loading" class="hidden">Carregando publicações...</p>
      </section>
    </div>

    <!-- Lateral direita (visível apenas em telas maiores) -->
    <!-- Mova esta seção para dentro do main-feed para que ela apareça em mobile -->
    <aside class="rightbar">
      <section id="follow-section">
        <h2>Sugestões para você</h2>
        <div id="users-list"></div>
      </section>
    </aside>
  </div>

  <!-- Seção de Perfil (inicialmente oculta) -->
  <section id="profile-section" class="hidden">
    <h2>Perfil</h2>
    <img id="profile-picture" src="https://via.placeholder.com/120" alt="Foto de Perfil">
    <p id="profile-user-email"></p>
    <input type="url" id="profile-picture-url-input" placeholder="URL da foto de perfil">
    <button id="update-profile-picture-btn">Atualizar Foto de Perfil</button>
    <button id="edit-profile-btn">Editar Perfil</button>
    <button id="my-posts-btn">Minhas Publicações</button>
    <button id="logout-btn-profile">Sair</button>

    <!-- Nova seção para as publicações do usuário -->
    <div id="profile-posts-section">
      <h3>Minhas Publicações</h3>
      <div id="profile-posts-feed">
        <!-- As publicações do usuário serão carregadas aqui -->
      </div>
      <p id="profile-posts-loading" class="hidden">Carregando suas publicações...</p>
    </div>
  </section>

</main>

<!-- Popup para Nova Publicação -->
<div class="popup-overlay hidden" id="post-section-popup">
  <div class="popup-content">
    <button class="close-popup-btn" aria-label="Fechar popup">×</button>
    <section id="post-section">
      <h2>Nova Publicação</h2>
      <textarea id="post-text" rows="3" placeholder="Escreva uma legenda..."></textarea>
      <input type="url" id="post-media-url" placeholder="Cole o link de uma imagem, vídeo do YouTube ou TikTok" />
      <button id="post-btn">Publicar</button>
      <p id="post-error" style="color:red;"></p>
    </section>
  </div>
</div>

<!-- Popup para Criar Story -->
<div class="popup-overlay hidden" id="story-creator-popup">
  <div class="popup-content">
    <button class="close-popup-btn" aria-label="Fechar popup">×</button>
    <section id="story-creator-section">
      <h2>Criar Novo Story</h2>
      <input type="url" id="story-media-url" placeholder="Cole o link de uma imagem ou vídeo do TikTok para o story" />
      <button id="create-story-btn">Publicar Story</button>
      <p id="story-creator-error" style="color:red;"></p>
    </section>
  </div>
</div>

<!-- Popup para Visualizar Stories -->
<div class="popup-overlay hidden" id="story-viewer-popup">
  <div class="popup-content">
    <button class="close-popup-btn" aria-label="Fechar popup">×</button>
    <div id="story-viewer-content">
      <!-- A mídia do story será carregada aqui (imagem ou vídeo) -->
      <img id="story-viewer-image" src="" alt="Story" class="hidden">
      <iframe id="story-viewer-video" src="" frameborder="0" allowfullscreen class="hidden"></iframe>

      <div id="story-viewer-info">
        <img id="story-viewer-user-pic" src="" alt="User Pic">
        <span id="story-viewer-username"></span>
        <span class="story-date" id="story-viewer-date"></span>
        <!-- Botão de exclusão de story (visível apenas para o criador) -->
        <button id="delete-story-btn" class="delete-story-btn hidden" title="Excluir Story"><i class="fas fa-trash-alt"></i></button>
      </div>
      <div id="story-viewer-controls">
        <button id="prev-story-btn"><i class="fas fa-chevron-left"></i></button>
        <button id="next-story-btn"><i class="fas fa-chevron-right"></i></button>
      </div>
    </div>
    <div id="story-viewer-actions">
      <div class="post-actions">
        <button id="story-like-btn"><i class="far fa-heart"></i></button>
      </div>
      <span class="post-likes-count" id="story-likes-count">0 curtidas</span>
      <div id="story-viewer-comments-list">
        <!-- Comentários do story serão carregados aqui -->
      </div>
      <div class="comment-form">
        <input type="text" id="story-comment-input" placeholder="Adicione um comentário..." />
        <button id="story-comment-btn">Publicar</button>
      </div>
    </div>
  </div>
</div>

<!-- NOVO: Popup para Notificações -->
<div class="popup-overlay hidden" id="notifications-popup">
  <div class="popup-content">
    <button class="close-popup-btn" aria-label="Fechar popup">×</button>
    <section id="notifications-section">
      <h2>Notificações</h2>
      <ul id="notifications-list">
        <!-- As notificações serão carregadas aqui pelo JavaScript -->
      </ul>
      <p id="no-notifications" class="hidden" style="text-align: center; color: #8e8e8e;">Nenhuma notificação nova.</p>
    </section>
  </div>
</div>


<!-- Menu de navegação inferior para mobile -->
<nav class="bottom-nav hidden" id="bottom-navigation">
  <a href="#" id="bottom-nav-home"><i class="fas fa-home"></i></a>
  <a href="#"><i class="fas fa-compass"></i></a>
  <a href="#" id="bottom-menu-criar"><i class="fas fa-plus-square"></i></a>
  <a href="#" id="bottom-menu-criar-story"><i class="fas fa-camera"></i></a>
  <a href="#" id="bottom-nav-notifications"><i class="fas fa-bell"></i><span id="notification-count" class="hidden"></span></a> <!-- NOVO: Ícone de Notificações -->
  <a href="#" id="bottom-nav-profile"><i class="fas fa-user-circle"></i></a>
</nav>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-storage-compat.js"></script>

<script>
  // Configuração do Firebase - substitua pelos seus dados do projeto
const firebaseConfig = {
  apiKey: "AIzaSyDgOFGtSwpOygRYZKRecgornhmJtw9bylo", // <== Substitua pelo seu apiKey
  authDomain: "gametwitter-24bc3.firebaseapp.com", // <== Substitua pelo seu authDomain
  projectId: "gametwitter-24bc3", // <== Substitua pelo seu projectId
  storageBucket: "gametwitter-24bc3.appspot.com", // <== Substitua pelo seu storageBucket
  messagingSenderId: "866667398712", // <== Substitua pelo seu messagingSenderId
  appId: "1:866667398712:web:edc1e6241aeac74caf88cd" // <== Substitua pelo seu appId
};


  // Inicializa Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();
 

  // Elementos do DOM
  const authSection = document.getElementById('auth-section');
  const appSection = document.getElementById('app-section');
  const emailInput = document.getElementById('email');
  const passwordInput = document.getElementById('password');
  const loginBtn = document.getElementById('login-btn');
  const signupBtn = document.getElementById('signup-btn');
  const authError = document.getElementById('auth-error');
  
  // Elementos do Header (Desktop)
  const userEmailSpanDesktop = document.getElementById('user-email-desktop');
  const logoutBtnDesktop = document.getElementById('logout-btn-desktop');
  const headerUserControlsDesktop = document.getElementById('header-user-controls-desktop');

  const postText = document.getElementById('post-text');
  const postMediaUrlInput = document.getElementById('post-media-url'); // Input para URL de mídia
  const postBtn = document.getElementById('post-btn');
  const postError = document.getElementById('post-error');

  const feedDiv = document.getElementById('feed');
  const loadingText = document.getElementById('loading');

  const usersListDiv = document.getElementById('users-list');
  const followingBar = document.getElementById('following-bar');
  const bottomNavigation = document.getElementById('bottom-navigation');

  // Elementos do Popup de Nova Publicação
  const menuCriarBtn = document.getElementById('menu-criar'); // Botão "Criar" na sidebar
  const bottomMenuCriarBtn = document.getElementById('bottom-menu-criar'); // Botão "Criar" no menu inferior
  const postSectionPopup = document.getElementById('post-section-popup'); // O popup em si
  const closePopupBtn = postSectionPopup.querySelector('.close-popup-btn'); // Botão "X" para fechar o popup

  // Elementos da Seção de Perfil
  const profileSection = document.getElementById('profile-section');
  const profilePicture = document.getElementById('profile-picture'); // Novo elemento
  const profilePictureUrlInput = document.getElementById('profile-picture-url-input'); // Novo elemento
  const updateProfilePictureBtn = document.getElementById('update-profile-picture-btn'); // Novo elemento
  const profileUserEmail = document.getElementById('profile-user-email');
  const editProfileBtn = document.getElementById('edit-profile-btn');
  const myPostsBtn = document.getElementById('my-posts-btn');
  const logoutBtnProfile = document.getElementById('logout-btn-profile');
  const profilePostsFeed = document.getElementById('profile-posts-feed'); // Novo elemento
  const profilePostsLoading = document.getElementById('profile-posts-loading'); // Novo elemento

  // Elementos de Navegação
  const sidebarProfileLink = document.getElementById('sidebar-profile');
  const bottomNavProfileLink = document.getElementById('bottom-nav-profile');
  const sidebarHomeLink = document.getElementById('sidebar-home');
  const bottomNavHomeLink = document.getElementById('bottom-nav-home');
  const mainFeedContent = document.getElementById('main-feed-content');

  // Elementos do Story Creator Popup
  const menuCriarStoryBtn = document.getElementById('menu-criar-story');
  const bottomMenuCriarStoryBtn = document.getElementById('bottom-menu-criar-story');
  const storyCreatorPopup = document.getElementById('story-creator-popup');
  const storyCreatorCloseBtn = storyCreatorPopup.querySelector('.close-popup-btn');
  const storyMediaUrlInput = document.getElementById('story-media-url');
  const createStoryBtn = document.getElementById('create-story-btn');
  const storyCreatorError = document.getElementById('story-creator-error');

  // Elementos do Story Viewer Popup
  const storyViewerPopup = document.getElementById('story-viewer-popup');
  const storyViewerCloseBtn = storyViewerPopup.querySelector('.close-popup-btn');
  const storyViewerImage = document.getElementById('story-viewer-image');
  const storyViewerVideo = document.getElementById('story-viewer-video'); // Novo elemento para vídeo
  const storyViewerUsername = document.getElementById('story-viewer-username');
  const storyViewerUserPic = document.getElementById('story-viewer-user-pic');
  const storyViewerDate = document.getElementById('story-viewer-date');
  const prevStoryBtn = document.getElementById('prev-story-btn');
  const nextStoryBtn = document.getElementById('next-story-btn');
  const storyLikeBtn = document.getElementById('story-like-btn');
  const storyLikesCount = document.getElementById('story-likes-count');
  const storyCommentInput = document.getElementById('story-comment-input');
  const storyCommentBtn = document.getElementById('story-comment-btn');
  const storyViewerCommentsList = document.getElementById('story-viewer-comments-list');
  const deleteStoryBtn = document.getElementById('delete-story-btn'); // Novo elemento para o botão de exclusão de story

  // NOVO: Elementos do Popup de Notificações
  const bottomNavNotificationsBtn = document.getElementById('bottom-nav-notifications');
  const notificationsPopup = document.getElementById('notifications-popup');
  const notificationsCloseBtn = notificationsPopup.querySelector('.close-popup-btn');
  const notificationsList = document.getElementById('notifications-list');
  const noNotificationsText = document.getElementById('no-notifications');
  const notificationCountSpan = document.getElementById('notification-count'); // NOVO: Elemento para a contagem de notificações


  let currentUser = null;
  let unsubscribeFeed = null;
  let unsubscribeProfilePosts = null; // Novo listener para posts do perfil
  let currentStories = []; // Armazena os stories do usuário atualmente visualizado
  let currentStoryIndex = 0; // Índice do story atual no visualizador
  let currentStoryUserId = null; // ID do usuário cujos stories estão sendo visualizados

  // Novo: Armazena os IDs dos stories que o usuário atual já visualizou
  let viewedStories = {}; // Estrutura: { userId: [storyId1, storyId2], ... }

  // Função para mostrar erro temporariamente
  function showError(element, message) {
    element.textContent = message;
    setTimeout(() => {
      element.textContent = '';
    }, 4000);
  }

  // Função para alternar a visibilidade das seções principais
  function showSection(sectionToShow) {
    const sections = [appSection, profileSection]; // Adicione outras seções principais aqui se houver
    sections.forEach(section => {
      if (section === sectionToShow) {
        section.classList.remove('hidden');
        // Adiciona uma classe para esconder em mobile se for a seção de perfil
        if (section === profileSection) {
            profileSection.classList.remove('hidden-mobile');
            // Se a seção de perfil está sendo mostrada, carrega as publicações do usuário
            if (currentUser) {
                loadProfileData(currentUser.uid); // Carrega dados do perfil, incluindo a foto
                loadProfilePosts(currentUser.uid);
            }
        }
      } else {
        section.classList.add('hidden');
        if (section === profileSection) {
            profileSection.classList.add('hidden-mobile');
            // Se a seção de perfil está sendo escondida, para de ouvir as publicações
            if (unsubscribeProfilePosts) {
                unsubscribeProfilePosts();
                unsubscribeProfilePosts = null;
            }
        }
      }
    });
  }

  // Login
  loginBtn.addEventListener('click', () => {
    const email = emailInput.value.trim();
    const password = passwordInput.value; // Corrigido para usar passwordInput.value
    if (!email || !password) {
      showError(authError, 'Preencha email e senha');
      return;
    }
    auth.signInWithEmailAndPassword(email, password)
      .catch(e => showError(authError, e.message));
  });

  // Cadastro
  signupBtn.addEventListener('click', () => {
    const emailValue = emailInput.value.trim(); // Use emailInput
    const passwordValue = passwordInput.value; // Use passwordInput
    if (!emailValue || !passwordValue) {
      showError(authError, 'Preencha email e senha');
      return;
    }
    auth.createUserWithEmailAndPassword(emailValue, passwordValue) // Use emailValue e passwordValue
      .then(cred => {
        // Criar perfil do usuário no Firestore
        return db.collection('users').doc(cred.user.uid).set({
          email: emailValue, // Use emailValue
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          followers: [],
          following: [],
          profilePictureUrl: '', // Adiciona um campo vazio para a URL da foto de perfil
          stories: [], // Novo campo para armazenar stories
          viewedStories: {}, // Novo campo para armazenar stories visualizados
          lastNotificationCheck: firebase.firestore.FieldValue.serverTimestamp() // NOVO: Campo para controlar notificações lidas
        });
      })
      .catch(e => showError(authError, e.message));
  });

  // Logout (botão do desktop)
  logoutBtnDesktop.addEventListener('click', () => {
    auth.signOut();
  });

  // Logout (botão do perfil)
  logoutBtnProfile.addEventListener('click', () => {
    auth.signOut();
  });

  // Atualiza UI após login/logout
  auth.onAuthStateChanged(async user => { // Adicionado 'async' aqui
    if (user) {
      currentUser = user;
      userEmailSpanDesktop.textContent = user.email.split('@')[0]; // Exibe apenas o nome de usuário no desktop header
      profileUserEmail.textContent = user.email; // Exibe o email completo na seção de perfil
      authSection.classList.add('hidden');
      
      // Carrega os stories visualizados do usuário logado
      const userDoc = await db.collection('users').doc(currentUser.uid).get();
      if (userDoc.exists) {
        viewedStories = userDoc.data().viewedStories || {};
      }

      // Mostra a seção principal do app por padrão
      showSection(appSection); 

      headerUserControlsDesktop.classList.remove('hidden'); // Mostra os controles do usuário no header (desktop)
      bottomNavigation.classList.remove('hidden'); // Mostra o menu inferior (mobile)
      loadUsersToFollow();
      loadFollowingUsersBar(); // Carrega a barra de usuários seguidos
      startFeedListener();
      // Não chame loadNotifications() aqui, pois ele será chamado ao abrir o popup
      // Em vez disso, configure um listener para o campo lastNotificationCheck
      setupNotificationListener(); // NOVO: Configura o listener para notificações
    } else {
      currentUser = null;
      viewedStories = {}; // Limpa os stories visualizados ao deslogar
      userEmailSpanDesktop.textContent = '';
      profileUserEmail.textContent = '';
      authSection.classList.remove('hidden');
      appSection.classList.add('hidden');
      profileSection.classList.add('hidden'); // Esconde a seção de perfil
      headerUserControlsDesktop.classList.add('hidden'); // Esconde os controles do usuário no header (desktop)
      bottomNavigation.classList.add('hidden'); // Esconde o menu inferior (mobile)
      if (unsubscribeFeed) unsubscribeFeed(); // Para de ouvir o feed
      if (unsubscribeProfilePosts) unsubscribeProfilePosts(); // Para de ouvir os posts do perfil
      feedDiv.innerHTML = '';
      usersListDiv.innerHTML = '';
      followingBar.innerHTML = ''; // Limpa a barra de seguidos
      profilePostsFeed.innerHTML = ''; // Limpa os posts do perfil
      notificationCountSpan.classList.add('hidden'); // Esconde a contagem ao deslogar
      notificationCountSpan.textContent = ''; // Limpa o texto da contagem
    }
  });

  // Postar
  postBtn.addEventListener('click', async () => {
    postError.textContent = '';
    const text = postText.value.trim();
    const mediaUrl = postMediaUrlInput.value.trim();

    if (!text && !mediaUrl) {
      showError(postError, 'Escreva algo ou cole um link de mídia.');
      return;
    }

    postBtn.disabled = true;
    postBtn.textContent = 'Publicando...';

    try {
      let finalMediaUrl = null;
      let mediaType = null; // 'image', 'youtube', 'tiktok', ou null

      if (mediaUrl) {
        // Processar URL de mídia
        if (mediaUrl.includes('youtube.com/watch?v=') || mediaUrl.includes('youtu.be/')) {
          // É um vídeo do YouTube
          finalMediaUrl = mediaUrl;
          mediaType = 'youtube';
        } else if (mediaUrl.includes('tiktok.com/')) {
          // É um vídeo do TikTok
          finalMediaUrl = getTikTokEmbedUrl(mediaUrl);
          if (finalMediaUrl) {
            mediaType = 'tiktok';
          } else {
            showError(postError, 'URL do TikTok inválida ou não suportada para incorporação.');
            postBtn.disabled = false;
            postBtn.textContent = 'Publicar';
            return;
          }
        }
        else if (/\.(jpeg|jpg|gif|png|webp|bmp)$/i.test(mediaUrl)) {
          // É uma imagem (verifica a extensão)
          finalMediaUrl = mediaUrl;
          mediaType = 'image';
        } else {
          showError(postError, 'URL de mídia inválida. Suporta apenas imagens diretas, links do YouTube ou TikTok.');
          postBtn.disabled = false;
          postBtn.textContent = 'Publicar';
          return;
        }
      }

      // Criar post no Firestore
      await db.collection('posts').add({
        userId: currentUser.uid,
        userEmail: currentUser.email,
        text: text,
        imageUrl: finalMediaUrl, // Usamos imageUrl para armazenar a URL da mídia, seja imagem ou vídeo
        mediaType: mediaType, // Tipo de mídia (image, youtube, tiktok)
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        likes: [],
        comments: []
      });

      postText.value = ''; // Limpa o campo de texto
      postMediaUrlInput.value = ''; // Limpa o input de URL de mídia
      postSectionPopup.classList.add('hidden'); // Fecha o popup após a publicação
    } catch (e) {
      showError(postError, 'Erro ao publicar: ' + e.message);
    }

    postBtn.disabled = false;
    postBtn.textContent = 'Publicar';
  });

  // Carregar usuários para seguir (Sugestões para você)
  async function loadUsersToFollow() {
    usersListDiv.innerHTML = 'Carregando usuários...';
    try {
      const usersSnapshot = await db.collection('users').get();
      const users = [];
      usersSnapshot.forEach(doc => {
        if (doc.id !== currentUser.uid) { // Não mostra o próprio usuário
          users.push({ id: doc.id, ...doc.data() });
        }
      });

      // Buscar dados do usuário atual para saber quem ele já segue
      const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
      const currentUserData = currentUserDoc.data();
      const following = currentUserData.following || [];

      usersListDiv.innerHTML = '';
      if (users.length === 0) {
        usersListDiv.textContent = 'Nenhum outro usuário cadastrado.';
        return;
      }

      let usersDisplayed = false;
      users.forEach(user => {
        // Apenas mostra usuários que o currentUser AINDA NÃO segue
        if (!following.includes(user.id)) {
          const div = document.createElement('div');
          div.classList.add('user-item');
          const nameSpan = document.createElement('span');
          nameSpan.classList.add('user-name');
          nameSpan.textContent = user.email.split('@')[0]; // Exibe apenas o nome de usuário
          const btn = document.createElement('button');
          btn.classList.add('follow-btn');
          btn.textContent = 'Seguir';
          btn.addEventListener('click', () => toggleFollow(user.id, btn));
          div.appendChild(nameSpan);
          div.appendChild(btn);
          usersListDiv.appendChild(div);
          usersDisplayed = true;
        }
      });

      if (!usersDisplayed) {
        usersListDiv.textContent = 'Você já segue todos os usuários disponíveis ou não há outros usuários.';
      }

    } catch (e) {
      usersListDiv.textContent = 'Erro ao carregar usuários: ' + e.message;
    }
  }

  // Carregar usuários que o usuário atual segue para a barra superior (incluindo stories)
  async function loadFollowingUsersBar() {
    followingBar.innerHTML = ''; // Limpa a barra antes de preencher
    try {
      const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
      const currentUserData = currentUserDoc.data();
      const followingIds = currentUserData.following || [];

      // Adiciona o próprio usuário no início da barra de stories
      const selfUserDoc = await db.collection('users').doc(currentUser.uid).get();
      if (selfUserDoc.exists) {
        const selfUserData = selfUserDoc.data();
        const selfDiv = document.createElement('div');
        selfDiv.classList.add('following-user-item');
        selfDiv.dataset.userId = currentUser.uid; // Adiciona o ID do usuário
        selfDiv.addEventListener('click', () => viewStories(currentUser.uid));

        // Estrutura para a borda do story
        const selfStoryCircle = document.createElement('div');
        selfStoryCircle.classList.add('story-circle');
        const selfInnerCircle = document.createElement('div');
        selfInnerCircle.classList.add('inner-circle');

        const selfImg = document.createElement('img');
        selfImg.src = selfUserData.profilePictureUrl || 'https://via.placeholder.com/60';
        selfImg.alt = selfUserData.email.split('@')[0];
        
        // Verifica se o próprio usuário tem stories ativos
        const selfStories = selfUserData.stories || [];
        const activeSelfStories = selfStories.filter(s => {
            const createdAtDate = s.createdAt instanceof firebase.firestore.Timestamp ? s.createdAt.toDate() : s.createdAt;
            return (new Date().getTime() - createdAtDate.getTime()) < (24 * 60 * 60 * 1000);
        });

        // Novo: Verifica se todos os stories ativos do próprio usuário foram visualizados
        const allSelfStoriesViewed = activeSelfStories.every(s => (viewedStories[currentUser.uid] || []).includes(s.id));

        if (activeSelfStories.length > 0 && !allSelfStoriesViewed) {
          selfStoryCircle.classList.add('has-story');
        } else {
          selfStoryCircle.classList.add('story-viewed'); // Borda cinza se não tem story novo ou todos foram vistos
        }

        selfInnerCircle.appendChild(selfImg);
        selfStoryCircle.appendChild(selfInnerCircle);
        selfDiv.appendChild(selfStoryCircle);

        const selfSpan = document.createElement('span');
        selfSpan.textContent = 'Seu Story'; // Texto para o próprio story
        selfDiv.appendChild(selfSpan);
        followingBar.appendChild(selfDiv);
      }


      if (followingIds.length === 0) {
        if (followingBar.children.length === 0) { // Se não houver nem o próprio story
            followingBar.textContent = 'Você ainda não segue ninguém e não tem stories.';
            followingBar.style.justifyContent = 'center'; // Centraliza o texto
        }
        return;
      }
      followingBar.style.justifyContent = 'flex-start'; // Volta ao padrão

      // Busca os dados de cada usuário seguido
      for (const userId of followingIds) {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const div = document.createElement('div');
          div.classList.add('following-user-item');
          div.dataset.userId = userId; // Adiciona o ID do usuário
          div.addEventListener('click', () => viewStories(userId));

          // Estrutura para a borda do story
          const storyCircle = document.createElement('div');
          storyCircle.classList.add('story-circle');
          const innerCircle = document.createElement('div');
          innerCircle.classList.add('inner-circle');

          const img = document.createElement('img');
          img.src = userData.profilePictureUrl || 'https://via.placeholder.com/60'; // Placeholder
          img.alt = userData.email.split('@')[0];
          
          // Verifica se o usuário seguido tem stories ativos (últimas 24h)
          const userStories = userData.stories || [];
          const activeUserStories = userStories.filter(s => {
            const createdAtDate = s.createdAt instanceof firebase.firestore.Timestamp ? s.createdAt.toDate() : s.createdAt;
            return (new Date().getTime() - createdAtDate.getTime()) < (24 * 60 * 60 * 1000);
          });

          // Novo: Verifica se todos os stories ativos deste usuário foram visualizados
          const allUserStoriesViewed = activeUserStories.every(s => (viewedStories[userId] || []).includes(s.id));

          if (activeUserStories.length > 0 && !allUserStoriesViewed) {
            storyCircle.classList.add('has-story');
          } else {
            storyCircle.classList.add('story-viewed'); // Borda cinza se não tem story novo ou todos foram vistos
          }

          innerCircle.appendChild(img);
          storyCircle.appendChild(innerCircle);
          div.appendChild(storyCircle);

          const span = document.createElement('span');
          span.textContent = userData.email.split('@')[0];
          div.appendChild(span);
          followingBar.appendChild(div);
        }
      }
    } catch (e) {
      followingBar.textContent = 'Erro ao carregar seguidos: ' + e.message;
    }
  }

  // Seguir / Desseguir usuário
  async function toggleFollow(userId, btn) {
    btn.disabled = true;
    try {
      const currentUserRef = db.collection('users').doc(currentUser.uid);
      const userToFollowRef = db.collection('users').doc(userId);

      // Verifica se o usuário atual já segue o usuário alvo
      const currentUserDoc = await currentUserRef.get();
      const currentUserData = currentUserDoc.data();
      const isFollowing = (currentUserData.following || []).includes(userId);

      if (isFollowing) {
        // Desseguir
        await currentUserRef.update({
          following: firebase.firestore.FieldValue.arrayRemove(userId)
        });
        await userToFollowRef.update({
          followers: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
        });
        btn.textContent = 'Seguir';
        btn.classList.remove('following');
      } else {
        // Seguir
        await currentUserRef.update({
          following: firebase.firestore.FieldValue.arrayUnion(userId)
        });
        await userToFollowRef.update({
          followers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
        });
        btn.textContent = 'Seguindo';
        btn.classList.add('following');
      }

      // Recarregar a lista de sugestões e a barra de seguidos
      loadUsersToFollow();
      loadFollowingUsersBar();

      // Atualizar feed para refletir posts dos seguidos
      if (unsubscribeFeed) unsubscribeFeed(); // Cancela o listener anterior
      startFeedListener(); // Inicia um novo listener com a lista atualizada de seguidos

    } catch (e) {
      alert('Erro ao seguir/desseguir: ' + e.message);
    }
    btn.disabled = false;
  }

  // Iniciar listener do feed principal
  async function startFeedListener() {
    feedDiv.innerHTML = '';
    loadingText.classList.remove('hidden');

    // Buscar lista de usuários que o atual segue + ele mesmo
    const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
    const currentUserData = currentUserDoc.data();
    let following = currentUserData.following || [];
    
    // Garante que o próprio usuário esteja sempre incluído na lista para o feed
    const usersToFetchPostsFrom = new Set(following);
    usersToFetchPostsFrom.add(currentUser.uid); // Adiciona o ID do usuário atual
    
    const usersToShow = Array.from(usersToFetchPostsFrom);

    // Query posts dos usuários seguidos e do próprio usuário, ordenados por data desc
    // Limitação: 'in' só aceita até 10 valores. Se 'usersToShow' for maior, precisaria de múltiplas queries.
    if (usersToShow.length === 0) {
        feedDiv.textContent = 'Nenhuma publicação para mostrar. Siga alguns usuários!';
        loadingText.classList.add('hidden');
        return;
    }
    
    unsubscribeFeed = db.collection('posts')
      .where('userId', 'in', usersToShow.slice(0, 10)) // Pega os primeiros 10 se houver mais
      .orderBy('createdAt', 'desc')
      .onSnapshot(snapshot => {
        feedDiv.innerHTML = '';
        if (snapshot.empty) {
          feedDiv.textContent = 'Nenhuma publicação para mostrar.';
          loadingText.classList.add('hidden');
          return;
        }
        snapshot.forEach(doc => {
          const post = { id: doc.id, ...doc.data() };
          feedDiv.appendChild(createPostElement(post));
        });
        loadingText.classList.add('hidden');
      }, err => {
        feedDiv.textContent = 'Erro ao carregar feed: ' + err.message;
        loadingText.classList.add('hidden');
      });
  }

  // Função para carregar as publicações do usuário logado na seção de perfil
  async function loadProfilePosts(userId) {
    profilePostsFeed.innerHTML = '';
    profilePostsLoading.classList.remove('hidden');

    if (unsubscribeProfilePosts) {
        unsubscribeProfilePosts(); // Cancela o listener anterior, se houver
    }

    unsubscribeProfilePosts = db.collection('posts')
      .where('userId', '==', userId)
      .orderBy('createdAt', 'desc')
      .onSnapshot(snapshot => {
        profilePostsFeed.innerHTML = '';
        if (snapshot.empty) {
          profilePostsFeed.textContent = 'Você ainda não fez nenhuma publicação.';
          profilePostsLoading.classList.add('hidden');
          return;
        }
        snapshot.forEach(doc => {
          const post = { id: doc.id, ...doc.data() };
          profilePostsFeed.appendChild(createPostElement(post)); // Reutiliza a função createPostElement
        });
        profilePostsLoading.classList.add('hidden');
      }, err => {
        profilePostsFeed.textContent = 'Erro ao carregar suas publicações: ' + err.message;
        profilePostsLoading.classList.add('hidden');
      });
  }

  // Função para carregar os dados do perfil do usuário
  async function loadProfileData(userId) {
    try {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        profileUserEmail.textContent = userData.email;
        profilePicture.src = userData.profilePictureUrl || 'https://via.placeholder.com/120'; // Define a imagem de perfil ou um placeholder
        profilePictureUrlInput.value = userData.profilePictureUrl || ''; // Preenche o input com a URL atual
      }
    } catch (e) {
      console.error("Erro ao carregar dados do perfil:", e);
    }
  }

  // Event listener para atualizar a foto de perfil
  updateProfilePictureBtn.addEventListener('click', async () => {
    const newProfilePictureUrl = profilePictureUrlInput.value.trim();
    if (newProfilePictureUrl) {
      try {
        await db.collection('users').doc(currentUser.uid).update({
          profilePictureUrl: newProfilePictureUrl
        });
        profilePicture.src = newProfilePictureUrl; // Atualiza a imagem exibida
        alert('Foto de perfil atualizada com sucesso!');
        loadFollowingUsersBar(); // Recarrega a barra de seguidos para atualizar a imagem lá também
      } catch (e) {
        alert('Erro ao atualizar foto de perfil: ' + e.message);
      }
    } else {
      alert('Por favor, insira uma URL válida para a foto de perfil.');
    }
  });


  // Criar elemento de post
  function createPostElement(post) {
    const div = document.createElement('div');
    div.classList.add('post');
    div.dataset.postId = post.id; // Adiciona o ID do post como um atributo de dados

    // Cabeçalho
    const header = document.createElement('div');
    header.classList.add('post-header');
    const userSpan = document.createElement('span');
    userSpan.classList.add('post-user');
    userSpan.textContent = post.userEmail.split('@')[0]; // Exibe apenas o nome de usuário
    const dateSpan = document.createElement('span');
    dateSpan.classList.add('post-date');
    if (post.createdAt && post.createdAt.toDate) {
      dateSpan.textContent = formatPostDate(post.createdAt.toDate());
    } else {
      dateSpan.textContent = '';
    }
    header.appendChild(userSpan);
    header.appendChild(dateSpan);

    // Botões de Editar/Excluir Post (apenas para o dono)
    if (currentUser && post.userId === currentUser.uid) {
      const ownerActionsDiv = document.createElement('div');
      ownerActionsDiv.classList.add('post-owner-actions');

      const editPostBtn = document.createElement('button');
      editPostBtn.innerHTML = '<i class="fas fa-edit"></i>';
      editPostBtn.title = 'Editar Post';
      editPostBtn.addEventListener('click', () => editPost(post));
      ownerActionsDiv.appendChild(editPostBtn);

      const deletePostBtn = document.createElement('button');
      deletePostBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
      deletePostBtn.title = 'Excluir Post';
      deletePostBtn.addEventListener('click', () => deletePost(post.id, post.imageUrl)); // Passa imageUrl para exclusão do Storage
      ownerActionsDiv.appendChild(deletePostBtn);

      header.appendChild(ownerActionsDiv);
    }

    div.appendChild(header);

    // Mídia (Imagem, YouTube ou TikTok)
    if (post.mediaType === 'image' && post.imageUrl) {
      const img = document.createElement('img');
      img.classList.add('post-image');
      img.src = post.imageUrl;
      img.alt = 'Imagem publicada pelo usuário';
      div.appendChild(img);
    } else if (post.mediaType === 'youtube' && post.imageUrl) {
      const youtubeId = getYouTubeVideoId(post.imageUrl);
      if (youtubeId) {
        const iframe = document.createElement('iframe');
        iframe.classList.add('post-video');
        iframe.src = `https://www.youtube.com/embed/${youtubeId}`;
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        div.appendChild(iframe);
      }
    } else if (post.mediaType === 'tiktok' && post.imageUrl) {
        const iframe = document.createElement('iframe');
        iframe.classList.add('post-tiktok-video');
        iframe.src = post.imageUrl; // A URL já deve ser a de embed
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        iframe.setAttribute('scrolling', 'no'); // TikTok embeds often need this
        div.appendChild(iframe);
    }
    else if (post.imageUrl && !post.mediaType) { // Compatibilidade com posts antigos que só tinham imageUrl
        // Se não tem mediaType mas tem imageUrl, assume que é imagem para compatibilidade
        const img = document.createElement('img');
        img.classList.add('post-image');
        img.src = post.imageUrl;
        img.alt = 'Imagem publicada pelo usuário';
        div.appendChild(img);
    }


    // Conteúdo do post (texto, ações, likes, comentários)
    const contentDiv = document.createElement('div');
    contentDiv.classList.add('post-content');

    // Ações: Curtir, Comentar
    const actionsDiv = document.createElement('div');
    actionsDiv.classList.add('post-actions');

    // Curtir
    const likeBtn = document.createElement('button');
    const liked = post.likes.includes(currentUser.uid);
    likeBtn.innerHTML = liked ? `<i class="fas fa-heart"></i>` : `<i class="far fa-heart"></i>`;
    if (liked) likeBtn.classList.add('liked');
    likeBtn.addEventListener('click', () => toggleLike(post, likeBtn));
    actionsDiv.appendChild(likeBtn);

    // Comentar (ícone de balão de fala)
    const commentBtn = document.createElement('button');
    commentBtn.innerHTML = `<i class="far fa-comment"></i>`;
    // O evento de clique para mostrar/esconder comentários será no post-comments-count
    actionsDiv.appendChild(commentBtn);

    contentDiv.appendChild(actionsDiv);

    // Contagem de likes
    const likesCountSpan = document.createElement('span');
    likesCountSpan.classList.add('post-likes-count');
    likesCountSpan.textContent = `${post.likes.length} curtidas`;
    contentDiv.appendChild(likesCountSpan);

    // Contagem de comentários
    const commentsCountSpan = document.createElement('span');
    commentsCountSpan.classList.add('post-comments-count');
    const commentCount = post.comments ? post.comments.length : 0;
    commentsCountSpan.textContent = `Ver todos os ${commentCount} comentários`;
    commentsCountSpan.addEventListener('click', () => toggleCommentsSection(div, post)); // Evento de clique para mostrar/esconder comentários
    contentDiv.appendChild(commentsCountSpan);

    // Texto
    const textP = document.createElement('p');
    textP.classList.add('post-text');
    const userEmailPart = post.userEmail.split('@')[0];
    textP.innerHTML = `<span class="post-user">${userEmailPart}</span> ${post.text || ''}`;
    contentDiv.appendChild(textP);

    div.appendChild(contentDiv);

    return div;
  }

  // Função para extrair o ID do vídeo do YouTube de uma URL
  function getYouTubeVideoId(url) {
    let videoId = null;
    const regex = /(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
    const match = url.match(regex);
    if (match && match[1]) {
      videoId = match[1];
    }
    return videoId;
  }

  // Função para extrair o URL de embed do TikTok
  function getTikTokEmbedUrl(url) {
    const match = url.match(/tiktok\.com\/@[\w.]+\/video\/(\d+)/);
    if (match && match[1]) {
      return `https://www.tiktok.com/embed/v2/${match[1]}?autoplay=1&loop=0`;
    }
    return null;
  }

  // Função para formatar a data do post
  function formatPostDate(date) {
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffMinutes = Math.floor(diffTime / (1000 * 60));
    const diffHours = Math.floor(diffTime / (1000 * 60 * 60));
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    if (diffMinutes < 60) {
      return `${diffMinutes}m`;
    } else if (diffHours < 24) {
      return `${diffHours}h`;
    } else if (diffDays < 7) {
      return `${diffDays}d`;
    } else {
      return date.toLocaleDateString('pt-BR', { day: 'numeric', month: 'numeric', year: 'numeric' });
    }
  }

  // Lógica de curtir/descurtir
  async function toggleLike(post, btn, isStory = false) {
    try {
      let docRef;
      let currentLikes;

      if (isStory) {
        // Para stories, o "post" é um objeto de story dentro do array 'stories' do usuário
        // Precisamos atualizar o story específico dentro do array
        docRef = db.collection('users').doc(post.userId);
        const userDoc = await docRef.get();
        if (!userDoc.exists) return;

        const userData = userDoc.data();
        let stories = userData.stories || [];
        const storyIndex = stories.findIndex(s => s.id === post.id); // Encontra o story pelo ID
        if (storyIndex === -1) return;

        currentLikes = stories[storyIndex].likes || [];
        const liked = currentLikes.includes(currentUser.uid);

        if (liked) {
          currentLikes = currentLikes.filter(id => id !== currentUser.uid);
        } else {
          currentLikes.push(currentUser.uid);
        }
        stories[storyIndex].likes = currentLikes;
        await docRef.update({ stories: stories });

        // Atualiza a UI do story viewer
        if (btn) {
            btn.innerHTML = currentLikes.includes(currentUser.uid) ? `<i class="fas fa-heart"></i>` : `<i class="far fa-heart"></i>`;
            if (currentLikes.includes(currentUser.uid)) btn.classList.add('liked');
            else btn.classList.remove('liked');
        }
        storyLikesCount.textContent = `${currentLikes.length} curtidas`;

      } else {
        // Lógica para posts normais
        docRef = db.collection('posts').doc(post.id);
        const postDoc = await docRef.get();
        if (!postDoc.exists) return;

        const postData = postDoc.data();
        currentLikes = postData.likes || [];
        const liked = currentLikes.includes(currentUser.uid);

        if (liked) {
          currentLikes = currentLikes.filter(id => id !== currentUser.uid);
        } else {
          currentLikes.push(currentUser.uid);
        }

        await docRef.update({ likes: currentLikes });
      }

      // A UI do feed principal será atualizada automaticamente pelo onSnapshot
    } catch (e) {
      alert('Erro ao curtir: ' + e.message);
    }
  }

  // Função para editar um post
  async function editPost(post) {
    const newText = prompt('Edite sua publicação:', post.text);
    if (newText !== null && newText.trim() !== '') {
      try {
        await db.collection('posts').doc(post.id).update({
          text: newText.trim()
        });
        // O listener do feed (onSnapshot) irá atualizar a UI automaticamente
      } catch (e) {
        alert('Erro ao editar publicação: ' + e.message);
      }
    }
  }

  // Função para excluir um post
  async function deletePost(postId, imageUrl) {
    if (confirm('Tem certeza que deseja excluir esta publicação?')) {
      try {
        // Excluir imagem do Storage, se existir e for um upload direto (não URL externa)
        // Verificamos se a URL começa com o bucket do Firebase Storage para evitar tentar deletar URLs externas
        const storageBucketPrefix = `https://firebasestorage.googleapis.com/v0/b/${firebaseConfig.storageBucket}/o/posts`;
        if (imageUrl && imageUrl.startsWith(storageBucketPrefix)) {
          const imageRef = storage.refFromURL(imageUrl);
          await imageRef.delete().catch(error => {
            // Ignorar erro se o arquivo não existir (já foi excluído ou URL inválida)
            console.warn('Erro ao excluir imagem do Storage (pode não existir ou não ser do Storage):', error);
          });
        }
        // Excluir post do Firestore
        await db.collection('posts').doc(postId).delete();
        // O listener do feed (onSnapshot) irá atualizar a UI automaticamente
      } catch (e) {
        alert('Erro ao excluir publicação: ' + e.message);
      }
    }
  }

  // Toggle comentários (para posts normais)
  function toggleCommentsSection(postDiv, post) {
    let commentsSection = postDiv.querySelector('#comments-section');
    let commentsContainer;

    if (commentsSection) {
      // Se a seção já existe, apenas alterna a visibilidade
      commentsSection.classList.toggle('hidden');
      return;
    }

    // Criar seção de comentários
    commentsSection = document.createElement('div');
    commentsSection.id = 'comments-section';
    
    commentsContainer = document.createElement('div');
    commentsContainer.classList.add('comments-container'); // Para estilizar a lista de comentários
    commentsSection.appendChild(commentsContainer);

    // Função para renderizar comentários
    const renderComments = (comments) => {
      commentsContainer.innerHTML = ''; // Limpa os comentários existentes
      if (comments && comments.length > 0) {
        comments.forEach((comment, index) => {
          const commentDiv = document.createElement('div');
          commentDiv.classList.add('comment');
          
          const textContainer = document.createElement('div');
          textContainer.classList.add('comment-text-container');
          const userSpan = document.createElement('span');
          userSpan.classList.add('comment-user');
          userSpan.textContent = comment.userEmail.split('@')[0] + ' ';
          const textSpan = document.createElement('span');
          textSpan.textContent = comment.text;
          textContainer.appendChild(userSpan);
          textContainer.appendChild(textSpan);
          commentDiv.appendChild(textContainer);

          // Botões de Editar/Excluir Comentário (apenas para o autor)
          if (currentUser && comment.userId === currentUser.uid) {
            const commentActionsDiv = document.createElement('div');
            commentActionsDiv.classList.add('comment-actions');

            const editCommentBtn = document.createElement('button');
            editCommentBtn.innerHTML = '<i class="fas fa-edit"></i>';
            editCommentBtn.title = 'Editar Comentário';
            editCommentBtn.addEventListener('click', () => editComment(post.id, index, comment.text, false));
            commentActionsDiv.appendChild(editCommentBtn);

            const deleteCommentBtn = document.createElement('button');
            deleteCommentBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
            deleteCommentBtn.title = 'Excluir Comentário';
            deleteCommentBtn.addEventListener('click', () => deleteComment(post.id, index, false));
            commentActionsDiv.appendChild(deleteCommentBtn);

            commentDiv.appendChild(commentActionsDiv);
          }
          commentsContainer.appendChild(commentDiv);
        });
      } else {
        commentsContainer.textContent = 'Nenhum comentário ainda.';
        commentsContainer.style.fontSize = '0.85rem';
        commentsContainer.style.color = '#8e8e8e';
      }
    };

    // Renderiza os comentários iniciais
    renderComments(post.comments);

    // Formulário para comentar
    const commentForm = document.createElement('div');
    commentForm.classList.add('comment-form');
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Adicione um comentário...';
    const submitBtn = document.createElement('button');
    submitBtn.type = 'button';
    submitBtn.textContent = 'Publicar';
    submitBtn.onclick = async () => {
      const text = input.value.trim();
      if (!text) return;
      try {
        const newComment = {
          userId: currentUser.uid,
          userEmail: currentUser.email,
          text: text,
          createdAt: new Date() 
        };
        
        // Adicionar comentário ao post no Firestore
        await db.collection('posts').doc(post.id).update({
          comments: firebase.firestore.FieldValue.arrayUnion(newComment)
        });

        input.value = ''; // Limpa o input

        // Melhoria: Adicionar o comentário à lista localmente para feedback imediato
        // Isso evita um pequeno atraso até o onSnapshot do feed atualizar
        const tempComment = {
            userId: currentUser.uid,
            userEmail: currentUser.email,
            text: text,
            createdAt: new Date() 
        };
        // Atualiza o array de comentários do objeto 'post' na memória
        if (!post.comments) {
            post.comments = [];
        }
        post.comments.push(tempComment);
        renderComments(post.comments); // Renderiza novamente a lista de comentários

        // Atualiza a contagem de comentários no post
        const commentsCountSpan = postDiv.querySelector('.post-comments-count');
        commentsCountSpan.textContent = `Ver todos os ${post.comments.length} comentários`;
        
      } catch (e) {
        alert('Erro ao comentar: ' + e.message);
      }
    };
    commentForm.appendChild(input);
    commentForm.appendChild(submitBtn);
    commentsSection.appendChild(commentForm);

    postDiv.querySelector('.post-content').appendChild(commentsSection); // Adiciona a seção de comentários dentro do post-content
  }

  // Função para editar um comentário (adaptada para posts e stories)
  async function editComment(parentId, commentIndex, currentText, isStory = false) {
    const newText = prompt('Edite seu comentário:', currentText);
    if (newText !== null && newText.trim() !== '') {
      try {
        let docRef;
        let commentsArray;

        if (isStory) {
          docRef = db.collection('users').doc(currentStoryUserId); // ParentId é o userId do story
          const userDoc = await docRef.get();
          if (!userDoc.exists) return;
          let stories = userDoc.data().stories || [];
          const story = stories.find(s => s.id === parentId); // Encontra o story pelo ID
          if (!story) return;
          commentsArray = story.comments || [];

          if (commentIndex >= 0 && commentIndex < commentsArray.length) {
            commentsArray[commentIndex].text = newText.trim();
            // Atualiza o story no array de stories do usuário
            await docRef.update({ stories: stories });
            renderStoryComments(commentsArray); // Atualiza a UI do story viewer
          }

        } else {
          docRef = db.collection('posts').doc(parentId); // ParentId é o postId
          const postDoc = await docRef.get();
          if (!postDoc.exists) return;
          commentsArray = postDoc.data().comments || [];

          if (commentIndex >= 0 && commentIndex < commentsArray.length) {
            commentsArray[commentIndex].text = newText.trim();
            await docRef.update({ comments: commentsArray });
            // O listener do feed (onSnapshot) irá atualizar a UI automaticamente
          }
        }
      } catch (e) {
        alert('Erro ao editar comentário: ' + e.message);
      }
    }
  }

  // Função para excluir um comentário (adaptada para posts e stories)
  async function deleteComment(parentId, commentIndex, isStory = false) {
    if (confirm('Tem certeza que deseja excluir este comentário?')) {
      try {
        let docRef;
        let commentsArray;

        if (isStory) {
          docRef = db.collection('users').doc(currentStoryUserId); // ParentId é o userId do story
          const userDoc = await docRef.get();
          if (!userDoc.exists) return;
          let stories = userDoc.data().stories || [];
          const story = stories.find(s => s.id === parentId); // Encontra o story pelo ID
          if (!story) return;
          commentsArray = story.comments || [];

          if (commentIndex >= 0 && commentIndex < commentsArray.length) {
            commentsArray.splice(commentIndex, 1); // Remove o comentário pelo índice
            // Atualiza o story no array de stories do usuário
            await docRef.update({ stories: stories });
            renderStoryComments(commentsArray); // Atualiza a UI do story viewer
          }

        } else {
          docRef = db.collection('posts').doc(parentId); // ParentId é o postId
          const postDoc = await docRef.get();
          if (!postDoc.exists) return;
          commentsArray = postDoc.data().comments || [];

          if (commentIndex >= 0 && commentIndex < commentsArray.length) {
            commentsArray.splice(commentIndex, 1); // Remove o comentário pelo índice
            await docRef.update({ comments: commentsArray });
            // O listener do feed (onSnapshot) irá atualizar a UI automaticamente
          }
        }
      } catch (e) {
        alert('Erro ao excluir comentário: ' + e.message);
      }
    }
  }

  // Event listeners para abrir o popup de nova publicação
  menuCriarBtn.addEventListener('click', (e) => {
    e.preventDefault(); // Previne o comportamento padrão do link
    postSectionPopup.classList.remove('hidden'); // Remove a classe 'hidden' para mostrar o popup
  });

  bottomMenuCriarBtn.addEventListener('click', (e) => {
    e.preventDefault(); // Previne o comportamento padrão do link
    postSectionPopup.classList.remove('hidden'); // Remove a classe 'hidden' para mostrar o popup
  });

  // Event listener para fechar o popup clicando no "X"
  closePopupBtn.addEventListener('click', () => {
    postSectionPopup.classList.add('hidden'); // Adiciona a classe 'hidden' para ocultar o popup
  });

  // Event listener para fechar o popup clicando fora do conteúdo
  postSectionPopup.addEventListener('click', (e) => {
    if (e.target === postSectionPopup) { // Verifica se o clique foi no overlay e não no conteúdo
      postSectionPopup.classList.add('hidden');
    }
  });

  // Event listeners para navegação (Perfil e Home)
  sidebarProfileLink.addEventListener('click', (e) => {
    e.preventDefault();
    showSection(profileSection);
  });

  bottomNavProfileLink.addEventListener('click', (e) => {
    e.preventDefault();
    showSection(profileSection);
  });

  sidebarHomeLink.addEventListener('click', (e) => {
    e.preventDefault();
    showSection(appSection);
  });

  bottomNavHomeLink.addEventListener('click', (e) => {
    e.preventDefault();
    showSection(appSection);
  });

  // Placeholder para botões do perfil
  editProfileBtn.addEventListener('click', () => {
    alert('Funcionalidade "Editar Perfil" em desenvolvimento!');
  });

  // O botão "Minhas Publicações" agora apenas rola para a seção de posts no perfil
  myPostsBtn.addEventListener('click', () => {
    const profilePostsSection = document.getElementById('profile-posts-section');
    if (profilePostsSection) {
      profilePostsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  });

  // =================================================================================
  // NOVAS FUNCIONALIDADES DE STORIES
  // =================================================================================

  // Abrir popup de criar story
  menuCriarStoryBtn.addEventListener('click', (e) => {
    e.preventDefault();
    storyCreatorPopup.classList.remove('hidden');
  });

  bottomMenuCriarStoryBtn.addEventListener('click', (e) => {
    e.preventDefault();
    storyCreatorPopup.classList.remove('hidden');
  });

  // Fechar popup de criar story
  storyCreatorCloseBtn.addEventListener('click', () => {
    storyCreatorPopup.classList.add('hidden');
    storyMediaUrlInput.value = '';
    storyCreatorError.textContent = '';
  });

  storyCreatorPopup.addEventListener('click', (e) => {
    if (e.target === storyCreatorPopup) {
      storyCreatorPopup.classList.add('hidden');
      storyMediaUrlInput.value = '';
      storyCreatorError.textContent = '';
    }
  });

  // Publicar Story
  createStoryBtn.addEventListener('click', async () => {
    storyCreatorError.textContent = '';
    const mediaUrl = storyMediaUrlInput.value.trim();

    if (!mediaUrl) {
      showError(storyCreatorError, 'Por favor, cole o link de uma imagem ou vídeo do TikTok para o story.');
      return;
    }

    let finalMediaUrl = null;
    let mediaType = null; // 'image', 'tiktok'

    // Validação de URL de imagem ou TikTok
    if (/\.(jpeg|jpg|gif|png|webp|bmp)$/i.test(mediaUrl)) {
      finalMediaUrl = mediaUrl;
      mediaType = 'image';
    } else if (mediaUrl.includes('tiktok.com/')) {
      finalMediaUrl = getTikTokEmbedUrl(mediaUrl);
      if (finalMediaUrl) {
        mediaType = 'tiktok';
      } else {
        showError(storyCreatorError, 'URL do TikTok inválida ou não suportada para incorporação.');
        return;
      }
    } else {
      showError(storyCreatorError, 'URL inválida. Suporta apenas imagens diretas ou links de vídeo do TikTok.');
      return;
    }

    createStoryBtn.disabled = true;
    createStoryBtn.textContent = 'Publicando...';

    try {
      const userRef = db.collection('users').doc(currentUser.uid);
      const userDoc = await userRef.get();
      const userData = userDoc.data();
      const currentStories = userData.stories || [];

      // Adiciona um ID único para o story
      const newStory = {
        id: db.collection('users').doc().id, // Gera um ID único para o story
        mediaUrl: finalMediaUrl, // Usamos mediaUrl para armazenar a URL da mídia
        mediaType: mediaType, // Tipo de mídia (image, tiktok)
        createdAt: new Date(), // CORREÇÃO: Use new Date() em vez de FieldValue.serverTimestamp()
        likes: [],
        comments: []
      };

      // Adiciona o novo story ao array de stories do usuário
      await userRef.update({
        stories: firebase.firestore.FieldValue.arrayUnion(newStory)
      });

      // Novo: Marca o próprio story como não visualizado para que a borda apareça
      if (viewedStories[currentUser.uid]) {
        viewedStories[currentUser.uid] = viewedStories[currentUser.uid].filter(id => id !== newStory.id);
      } else {
        viewedStories[currentUser.uid] = [];
      }
      await db.collection('users').doc(currentUser.uid).update({
        viewedStories: viewedStories
      });


      storyMediaUrlInput.value = '';
      storyCreatorPopup.classList.add('hidden');
      alert('Story publicado com sucesso!');
      loadFollowingUsersBar(); // Atualiza a barra de stories
    } catch (e) {
      showError(storyCreatorError, 'Erro ao publicar story: ' + e.message);
    }

    createStoryBtn.disabled = false;
    createStoryBtn.textContent = 'Publicar Story';
  });

  // Visualizar Stories
  async function viewStories(userId) {
    currentStoryUserId = userId; // Armazena o ID do usuário cujos stories estão sendo vistos
    try {
      const userDoc = await db.collection('users').doc(userId).get();
      if (!userDoc.exists) {
        alert('Usuário não encontrado.');
        return;
      }
      const userData = userDoc.data();
      const userStories = userData.stories || [];

      // Filtra stories ativos (últimas 24h) e ordena por data
      currentStories = userStories
        .filter(s => {
          // Garante que s.createdAt é um Timestamp antes de chamar toDate()
          const createdAtDate = s.createdAt instanceof firebase.firestore.Timestamp ? s.createdAt.toDate() : s.createdAt;
          return (new Date().getTime() - createdAtDate.getTime()) < (24 * 60 * 60 * 1000);
        })
        .sort((a, b) => {
          const dateA = a.createdAt instanceof firebase.firestore.Timestamp ? a.createdAt.toDate() : a.createdAt;
          const dateB = b.createdAt instanceof firebase.firestore.Timestamp ? b.createdAt.toDate() : b.createdAt;
          return dateA.getTime() - dateB.getTime();
        });

      if (currentStories.length === 0) {
        alert('Este usuário não tem stories ativos no momento.');
        return;
      }

      // Preenche informações do usuário no viewer
      storyViewerUsername.textContent = userData.email.split('@')[0];
      storyViewerUserPic.src = userData.profilePictureUrl || 'https://via.placeholder.com/30';

      // Mostra/esconde o botão de exclusão
      if (currentUser && userId === currentUser.uid) {
        deleteStoryBtn.classList.remove('hidden');
      } else {
        deleteStoryBtn.classList.add('hidden');
      }

      currentStoryIndex = 0;
      renderStory(currentStories[currentStoryIndex]);
      storyViewerPopup.classList.remove('hidden');

      // Novo: Marca o primeiro story como visualizado ao abrir o viewer
      markStoryAsViewed(currentStoryUserId, currentStories[currentStoryIndex].id);

    } catch (e) {
      alert('Erro ao carregar stories: ' + e.message);
      console.error(e);
    }
  }

  // Renderiza um story específico no visualizador
  function renderStory(story) {
    // Esconde ambos os elementos de mídia primeiro
    storyViewerImage.classList.add('hidden');
    storyViewerVideo.classList.add('hidden');
    storyViewerImage.src = '';
    storyViewerVideo.src = '';

    if (story.mediaType === 'image') {
      storyViewerImage.src = story.mediaUrl;
      storyViewerImage.classList.remove('hidden');
    } else if (story.mediaType === 'tiktok') {
      storyViewerVideo.src = story.mediaUrl;
      storyViewerVideo.classList.remove('hidden');
    } else {
      // Fallback para stories antigos ou sem mediaType definido (assumir imagem)
      storyViewerImage.src = story.mediaUrl || story.imageUrl; // Compatibilidade com 'imageUrl' antigo
      storyViewerImage.classList.remove('hidden');
    }

    // Garante que story.createdAt é um objeto Date antes de formatar
    const createdAtDate = story.createdAt instanceof firebase.firestore.Timestamp ? story.createdAt.toDate() : story.createdAt;
    storyViewerDate.textContent = formatPostDate(createdAtDate);

    // Atualiza o estado do botão de like
    const liked = story.likes.includes(currentUser.uid);
    storyLikeBtn.innerHTML = liked ? `<i class="fas fa-heart"></i>` : `<i class="far fa-heart"></i>`;
    if (liked) storyLikeBtn.classList.add('liked');
    else storyLikeBtn.classList.remove('liked');
    storyLikesCount.textContent = `${story.likes.length} curtidas`;

    // Renderiza os comentários do story
    renderStoryComments(story.comments || []);

    // Habilita/desabilita botões de navegação
    prevStoryBtn.disabled = currentStoryIndex === 0;
    nextStoryBtn.disabled = currentStoryIndex === currentStories.length - 1;
  }

  // Renderiza a lista de comentários para um story
  function renderStoryComments(comments) {
    storyViewerCommentsList.innerHTML = '';
    if (comments && comments.length > 0) {
      comments.forEach((comment, index) => {
        const commentDiv = document.createElement('div');
        commentDiv.classList.add('comment');
        
        const textContainer = document.createElement('div');
        textContainer.classList.add('comment-text-container');
        const userSpan = document.createElement('span');
        userSpan.classList.add('comment-user');
        userSpan.textContent = comment.userEmail.split('@')[0] + ' ';
        const textSpan = document.createElement('span');
        textSpan.textContent = comment.text;
        textContainer.appendChild(userSpan);
        textContainer.appendChild(textSpan);
        commentDiv.appendChild(textContainer);

        // Botões de Editar/Excluir Comentário (apenas para o autor)
        if (currentUser && comment.userId === currentUser.uid) {
          const commentActionsDiv = document.createElement('div');
          commentActionsDiv.classList.add('comment-actions');

          const editCommentBtn = document.createElement('button');
          editCommentBtn.innerHTML = '<i class="fas fa-edit"></i>';
          editCommentBtn.title = 'Editar Comentário';
          editCommentBtn.addEventListener('click', () => editComment(currentStories[currentStoryIndex].id, index, comment.text, true));
          commentActionsDiv.appendChild(editCommentBtn);

          const deleteCommentBtn = document.createElement('button');
          deleteCommentBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
          deleteCommentBtn.title = 'Excluir Comentário';
          deleteCommentBtn.addEventListener('click', () => deleteComment(currentStories[currentStoryIndex].id, index, true));
          commentActionsDiv.appendChild(deleteCommentBtn);

          commentDiv.appendChild(commentActionsDiv);
        }
        storyViewerCommentsList.appendChild(commentDiv);
      });
    } else {
      storyViewerCommentsList.textContent = 'Nenhum comentário ainda.';
      storyViewerCommentsList.style.fontSize = '0.85rem';
      storyViewerCommentsList.style.color = '#8e8e8e';
    }
  }


  // Navegação de Stories
  prevStoryBtn.addEventListener('click', () => {
    if (currentStoryIndex > 0) {
      currentStoryIndex--;
      renderStory(currentStories[currentStoryIndex]);
      // Novo: Marca o story anterior como visualizado
      markStoryAsViewed(currentStoryUserId, currentStories[currentStoryIndex].id);
    }
  });

  nextStoryBtn.addEventListener('click', () => {
    if (currentStoryIndex < currentStories.length - 1) {
      currentStoryIndex++;
      renderStory(currentStories[currentStoryIndex]);
      // Novo: Marca o próximo story como visualizado
      markStoryAsViewed(currentStoryUserId, currentStories[currentStoryIndex].id);
    } else {
      // Se for o último story, fecha o visualizador
      storyViewerPopup.classList.add('hidden');
      // Novo: Recarrega a barra de seguidos para atualizar o estado da borda
      loadFollowingUsersBar();
    }
  });

  // Fechar popup de visualização de story
  storyViewerCloseBtn.addEventListener('click', () => {
    storyViewerPopup.classList.add('hidden');
    // Novo: Recarrega a barra de seguidos para atualizar o estado da borda
    loadFollowingUsersBar();
  });

  storyViewerPopup.addEventListener('click', (e) => {
    if (e.target === storyViewerPopup) {
      storyViewerPopup.classList.add('hidden');
      // Novo: Recarrega a barra de seguidos para atualizar o estado da borda
    }
  });

  // Curtir Story
  storyLikeBtn.addEventListener('click', () => {
    if (currentStories.length > 0) {
      toggleLike({
        id: currentStories[currentStoryIndex].id,
        userId: currentStoryUserId // Passa o userId do dono do story
      }, storyLikeBtn, true); // isStory = true
    }
  });

  // Comentar Story
  storyCommentBtn.addEventListener('click', async () => {
    const text = storyCommentInput.value.trim();
    if (!text || currentStories.length === 0) return;

    try {
      const userRef = db.collection('users').doc(currentStoryUserId);
      const userDoc = await userRef.get();
      if (!userDoc.exists) return;

      let stories = userDoc.data().stories || [];
      const storyIndex = stories.findIndex(s => s.id === currentStories[currentStoryIndex].id);
      if (storyIndex === -1) return;

      const newComment = {
        userId: currentUser.uid,
        userEmail: currentUser.email,
        text: text,
        createdAt: new Date()
      };

      // Adiciona o comentário ao story específico
      if (!stories[storyIndex].comments) {
        stories[storyIndex].comments = [];
      }
      stories[storyIndex].comments.push(newComment);

      await userRef.update({ stories: stories });

      storyCommentInput.value = ''; // Limpa o input

      // Atualiza a UI do story viewer com o novo comentário
      renderStoryComments(stories[storyIndex].comments);

    } catch (e) {
      alert('Erro ao comentar no story: ' + e.message);
    }
  });

  // NOVO: Função para marcar um story como visualizado
  async function markStoryAsViewed(storyOwnerId, storyId) {
    if (!currentUser || !storyOwnerId || !storyId) return;

    // Se o story for do próprio usuário, não marca como visualizado para ele mesmo
    if (storyOwnerId === currentUser.uid) {
        return;
    }

    if (!viewedStories[storyOwnerId]) {
      viewedStories[storyOwnerId] = [];
    }

    if (!viewedStories[storyOwnerId].includes(storyId)) {
      viewedStories[storyOwnerId].push(storyId);
      try {
        await db.collection('users').doc(currentUser.uid).update({
          [`viewedStories.${storyOwnerId}`]: firebase.firestore.FieldValue.arrayUnion(storyId)
        });
        // Não recarrega a barra aqui para evitar piscar durante a navegação dos stories
        // A barra será recarregada ao fechar o viewer
      } catch (e) {
        console.error("Erro ao marcar story como visualizado:", e);
      }
    }
  }

  // NOVO: Função para excluir um story
  deleteStoryBtn.addEventListener('click', async () => {
    if (!currentUser || !currentStoryUserId || currentStories.length === 0) return;

    const storyToDelete = currentStories[currentStoryIndex];

    if (currentUser.uid !== currentStoryUserId) {
      alert('Você não tem permissão para excluir este story.');
      return;
    }

    if (confirm('Tem certeza que deseja excluir este story?')) {
      try {
        const userRef = db.collection('users').doc(currentStoryUserId);
        const userDoc = await userRef.get();
        if (!userDoc.exists) return;

        let stories = userDoc.data().stories || [];
        const updatedStories = stories.filter(s => s.id !== storyToDelete.id);

        await userRef.update({ stories: updatedStories });

        // Se o story excluído for uma imagem do Storage, também a exclua de lá
        // (Assumindo que stories do Storage teriam uma URL específica, similar aos posts)
        const storageBucketPrefix = `https://firebasestorage.googleapis.com/v0/b/${firebaseConfig.storageBucket}/o/stories`; // Ajuste o caminho se seus stories forem em outro lugar
        if (storyToDelete.mediaUrl && storyToDelete.mediaUrl.startsWith(storageBucketPrefix)) {
          const imageRef = storage.refFromURL(storyToDelete.mediaUrl);
          await imageRef.delete().catch(error => {
            console.warn('Erro ao excluir mídia do story do Storage (pode não existir ou não ser do Storage):', error);
          });
        }

        alert('Story excluído com sucesso!');
        storyViewerPopup.classList.add('hidden'); // Fecha o visualizador
        loadFollowingUsersBar(); // Atualiza a barra de stories
      } catch (e) {
        alert('Erro ao excluir story: ' + e.message);
        console.error(e);
      }
    }
  });

  // =================================================================================
  // NOVO: FUNCIONALIDADES DE NOTIFICAÇÕES
  // =================================================================================

  // Event listener para abrir o popup de notificações
  bottomNavNotificationsBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    notificationsPopup.classList.remove('hidden');
    await loadNotifications(); // Carrega as notificações ao abrir o popup
    // NOVO: Marca o timestamp da última vez que o usuário verificou as notificações
    if (currentUser) {
        await db.collection('users').doc(currentUser.uid).update({
            lastNotificationCheck: firebase.firestore.FieldValue.serverTimestamp()
        });
        // Após marcar como lido, esconde a contagem imediatamente
        notificationCountSpan.classList.add('hidden');
        notificationCountSpan.textContent = '';
    }
  });

  // Event listener para fechar o popup de notificações
  notificationsCloseBtn.addEventListener('click', () => {
    notificationsPopup.classList.add('hidden');
  });

  notificationsPopup.addEventListener('click', (e) => {
    if (e.target === notificationsPopup) {
      notificationsPopup.classList.add('hidden');
    }
  });

  // NOVO: Variável para armazenar o timestamp da última verificação de notificações
  let lastNotificationCheckTimestamp = null;

  // NOVO: Função para configurar um listener em tempo real para o campo lastNotificationCheck
  function setupNotificationListener() {
    if (!currentUser) return;

    db.collection('users').doc(currentUser.uid)
      .onSnapshot(async (doc) => {
        if (doc.exists) {
          const userData = doc.data();
          lastNotificationCheckTimestamp = userData.lastNotificationCheck;
          // Recarrega as notificações para atualizar a contagem
          await updateNotificationCount();
        }
      }, (error) => {
        console.error("Erro ao ouvir o documento do usuário para notificações:", error);
      });
  }

  // NOVO: Função para atualizar apenas a contagem de notificações não lidas
  async function updateNotificationCount() {
    if (!currentUser) {
      notificationCountSpan.classList.add('hidden');
      notificationCountSpan.textContent = '';
      return;
    }

    let unreadCount = 0;
    const myNotifications = [];

    try {
      // 1. Buscar posts do usuário logado
      const myPostsSnapshot = await db.collection('posts')
        .where('userId', '==', currentUser.uid)
        .orderBy('createdAt', 'desc')
        .get();

      myPostsSnapshot.forEach(postDoc => {
        const post = { id: postDoc.id, ...postDoc.data() };

        // Notificações de Curtidas
        (post.likes || []).forEach(likerId => {
          if (likerId !== currentUser.uid) {
            const notificationTime = new Date(post.createdAt.seconds * 1000);
            if (!lastNotificationCheckTimestamp || notificationTime > lastNotificationCheckTimestamp.toDate()) {
              unreadCount++;
            }
          }
        });

        // Notificações de Comentários
        (post.comments || []).forEach(comment => {
          if (comment.userId !== currentUser.uid) {
            const notificationTime = comment.createdAt instanceof firebase.firestore.Timestamp ? comment.createdAt.toDate() : comment.createdAt;
            if (!lastNotificationCheckTimestamp || notificationTime > lastNotificationCheckTimestamp.toDate()) {
              unreadCount++;
            }
          }
        });
      });

      // 2. Buscar stories do usuário logado para notificações de likes/comments
      const userDoc = await db.collection('users').doc(currentUser.uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        const myStories = userData.stories || [];

        myStories.forEach(story => {
          // Notificações de Curtidas em Stories
          (story.likes || []).forEach(likerId => {
            if (likerId !== currentUser.uid) {
              const notificationTime = story.createdAt instanceof firebase.firestore.Timestamp ? story.createdAt.toDate() : story.createdAt;
              if (!lastNotificationCheckTimestamp || notificationTime > lastNotificationCheckTimestamp.toDate()) {
                unreadCount++;
              }
            }
          });

          // Notificações de Comentários em Stories
          (story.comments || []).forEach(comment => {
            if (comment.userId !== currentUser.uid) {
              const notificationTime = comment.createdAt instanceof firebase.firestore.Timestamp ? comment.createdAt.toDate() : comment.createdAt;
              if (!lastNotificationCheckTimestamp || notificationTime > lastNotificationCheckTimestamp.toDate()) {
                unreadCount++;
              }
            }
          });
        });
      }

      if (unreadCount > 0) {
        notificationCountSpan.textContent = unreadCount;
        notificationCountSpan.classList.remove('hidden');
      } else {
        notificationCountSpan.classList.add('hidden');
      }

    } catch (e) {
      console.error("Erro ao atualizar contagem de notificações:", e);
      notificationCountSpan.classList.add('hidden');
    }
  }


  // Função para carregar e exibir as notificações completas no popup
  async function loadNotifications() {
    notificationsList.innerHTML = ''; // Limpa a lista atual
    noNotificationsText.classList.add('hidden'); // Esconde a mensagem de "nenhuma notificação"
    // A contagem será atualizada pelo listener, então não a manipulamos diretamente aqui

    if (!currentUser) {
      notificationsList.innerHTML = '<li>Faça login para ver suas notificações.</li>';
      return;
    }

    const myNotifications = [];

    try {
      // 1. Buscar posts do usuário logado
      const myPostsSnapshot = await db.collection('posts')
        .where('userId', '==', currentUser.uid)
        .orderBy('createdAt', 'desc')
        .get();

      myPostsSnapshot.forEach(postDoc => {
        const post = { id: postDoc.id, ...postDoc.data() };

        // Notificações de Curtidas
        (post.likes || []).forEach(likerId => {
          if (likerId !== currentUser.uid) { // Não notificar sobre suas próprias curtidas
            myNotifications.push({
              type: 'like',
              userId: likerId,
              postId: post.id,
              postText: post.text ? post.text.substring(0, 50) + '...' : 'seu post',
              createdAt: new Date(post.createdAt.seconds * 1000) // Usar a data do post como referência para curtidas
            });
          }
        });

        // Notificações de Comentários
        (post.comments || []).forEach(comment => {
          if (comment.userId !== currentUser.uid) { // Não notificar sobre seus próprios comentários
            myNotifications.push({
              type: 'comment',
              userId: comment.userId,
              postId: post.id,
              postText: post.text ? post.text.substring(0, 50) + '...' : 'seu post',
              commentText: comment.text,
              createdAt: comment.createdAt instanceof firebase.firestore.Timestamp ? comment.createdAt.toDate() : comment.createdAt
            });
          }
        });
      });

      // 2. Buscar stories do usuário logado para notificações de likes/comments
      const userDoc = await db.collection('users').doc(currentUser.uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        const myStories = userData.stories || [];

        myStories.forEach(story => {
          // Notificações de Curtidas em Stories
          (story.likes || []).forEach(likerId => {
            if (likerId !== currentUser.uid) {
              myNotifications.push({
                type: 'story_like',
                userId: likerId,
                storyId: story.id,
                storyMedia: story.mediaType === 'image' ? 'sua imagem' : 'seu vídeo',
                createdAt: story.createdAt instanceof firebase.firestore.Timestamp ? story.createdAt.toDate() : story.createdAt
              });
            }
          });

          // Notificações de Comentários em Stories
          (story.comments || []).forEach(comment => {
            if (comment.userId !== currentUser.uid) {
              myNotifications.push({
                type: 'story_comment',
                userId: comment.userId,
                storyId: story.id,
                storyMedia: story.mediaType === 'image' ? 'sua imagem' : 'seu vídeo',
                commentText: comment.text,
                createdAt: comment.createdAt instanceof firebase.firestore.Timestamp ? comment.createdAt.toDate() : comment.createdAt
              });
            }
          });
        });
      }


      // Ordenar notificações pela data mais recente
      myNotifications.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

      // Renderizar notificações
      if (myNotifications.length === 0) {
        noNotificationsText.classList.remove('hidden');
      } else {
        // Buscar nomes de usuário para exibir
        const userIds = new Set(myNotifications.map(n => n.userId));
        const usersMap = new Map();
        for (const userId of userIds) {
          const userDoc = await db.collection('users').doc(userId).get();
          if (userDoc.exists) {
            usersMap.set(userId, userDoc.data().email.split('@')[0]);
          }
        }

        myNotifications.forEach(notification => {
          const li = document.createElement('li');
          const username = usersMap.get(notification.userId) || 'Usuário Desconhecido';
          const formattedDate = formatPostDate(notification.createdAt);

          if (notification.type === 'like') {
            li.innerHTML = `<strong>${username}</strong> curtiu ${notification.postText}. <span class="notification-date">${formattedDate}</span>`;
          } else if (notification.type === 'comment') {
            li.innerHTML = `<strong>${username}</strong> comentou "${notification.commentText}" em ${notification.postText}. <span class="notification-date">${formattedDate}</span>`;
          } else if (notification.type === 'story_like') {
            li.innerHTML = `<strong>${username}</strong> curtiu ${notification.storyMedia} no seu story. <span class="notification-date">${formattedDate}</span>`;
          } else if (notification.type === 'story_comment') {
            li.innerHTML = `<strong>${username}</strong> comentou "${notification.commentText}" em ${notification.storyMedia} no seu story. <span class="notification-date">${formattedDate}</span>`;
          }
          notificationsList.appendChild(li);
        });
      }

    } catch (e) {
      console.error("Erro ao carregar notificações:", e);
      notificationsList.innerHTML = '<li>Erro ao carregar notificações.</li>';
    }
  }

</script>
</body>
</html>
